package 챕터11_기본API클래스.ㄷ_Object클래스.ㄱ_객체비교_equals;

public class Equals {
	// 다음은 Object의 equals() 메소드이다.
	
	//	public boolean equals(Object onj) {...}
	
	// equals() 메소드의 매개 타입은 Object인데, 이것은 모든 객체가 매개값으로 대입될 수 있음을 말한다.
	// 그 이유는 Object가 최상위 타입이므로 모든 객체는 Object 타입으로 자동 타입 변환될 수 있기 때문이다.
	// Object 클래스의 equals() 메소드는 비교 연산자인 ==과 동일한 결과를 리턴한다.
	// 두 객체가 동일한 객체라면 true를 리턴하고 그렇지 않으면 false를 리턴한다
	
	// 	Object obj1 = new Object();
	// 	Object obj2 = new Object();
	//
	//	boolean result = obj1.equals(obj2); ---┐
	//					기준 객체		비교 객체	   | 결과가 동일
	//	boolean result = (obj1 == obj2) ◀---ㅡㅡ┘
	
	// 자바에서는 두 객체를 동등 비교할 때 equals() 메소드를 흔히 사용한다.
	// equals() 메소드는 두 객체를 비교해서 논리적으로 동등하면 true를 리턴하고, 그렇지 않으면 false를 리턴한다.
	// 논리적으로 동등하다는 것은 같은 객체이건 다른 객체이건 상관없이 객체가 저장하고 있는 데이터가 동일함을 뜻한다.
	// 예를 들어 String 객체의 equals() 메소드는 String 객체의 번지를 비교하는 것이 아니고, 문자열이 동일한지 조사한다.
	// 이것이 가능한 이유는 String 클래스가 Object의 equals() 메소드를 재정의(오버라이딩)해서 번지 비교가 아닌 문자열을 비교로 변경했기 때문이다.
	// Object의 equals() 메소드는 직접 사용되지 않고 하위 클래스에서 재정의하여 논리적으로 동등 비교할때 이용된다.
	// 예로 Member 객체는 다르지만 id 필드값이 같으면 논리적으로 동등한 객체로 취급하고 싶을 때 Object의 equals() 메소드를 재정의해서 비교하면 된다.
	
	// equals() 메소드를 재정의할 때에는 매개값(비교 객체)이 기준 객체와 동일한 타입의 객체인지 먼저 확인해야 한다.
	// Object 타입의 매개 변수는 모든 객체가 매개값으로 제공될 수 있기 때문에 instanceof 연산자로 기준 객체와 동일한 타입인지 제일 먼저 확인해야 한다.
	// 만약 비교 객체가 다른 타입이라면 equals() 메소드는 false를 리턴해야한다.
	// 비교 객체가 동일한 타입이라면 기준 객체 타입으로 강제 타입 변환해서 필드값이 동일한지 검사하면 된다.
	// 필드값이 모두 동일하다면 true를 리턴하고 그렇지 않으면 false를 리턴하도록 작성한다.
}
