package 챕터11_기본API클래스.ㅁ_System클래스.ㄴ_쓰레기수집기gc;

public class 쓰레기수집기실행gc {
	// 자바는 개발자가 메모리를 직접 코드로 관리하지 않고 JVM이 알아서 자동으로 관리한다.
	// JVM은 메모리가 부족할 때와 CPU가 한가할 때에 쓰레기 수집기를 실행시켜 사용하지 않는 객체를 자동 제거한다.
	// 다음과 같이 new 연산자로 Car 객체를 생성하고 변수 myCar 객체 번지를 대입했다고 가정하자.
	
	//	스택 영역						힙 영역
	//	maCar □	------------------->Car 객체
	
	// 만약 변수 myCar에 null을 대입하면, myCar는 객체의 번지를 잃게 된다. 객체의 번지를 모르니, 더 이상 Car 객체는 사용할 수가 없고 이제부터 쓰레기가 된다.
	
	//	스택 영역						힙 영역
	//	myCar null					Car 객체 <- 쓰레기 객체
	
	// 변수 myCar가 다른 Car 객체를 참조할 경우도 마찬가지다. 이전 객체의 번지를 잃기 때문에 이전 객체는 쓰레기가 된다.
	
	//	Car myCar = new Car(); // 이전 참조 객체
	//	myCar = new Car() // 현재 참조 객체
	
	//	스택 영역						힙 영역
	//	myCar □						이전 참조 객체 -> 쓰레기 객체
	//    └------------------------>현재 참조 객체
	
	// 쓰레기 수집기는 개발자가 직접 코드로 실행시킬 수 없고, JVM에게 가능한한 빨리 실행해 달라고 요청할 수는 있다.
	// 이것이 System.gc() 메소드이다. System.gc() 메소드가 호출되면 쓰레기 수집기가 바로 실행되는 것은 아니고, 
	// JVM은 빠른 시간 내에 실행시키기위해 노력한다.
	
	// System.gc();
	
	// 쓰레기가 생길 때마다 쓰레기 수집기가 동작한다면 정작 수행되어야 할 프로그램의 속도가 떨어지기 때문에 성능 측면에서 좋지 않다.
	// 그리고 메모리가 충분하다면 굳이 쓰레기 수집기를 실행할 필요가 없다. gc() 메소드는 메모리가 열악하지 않은 환경이라면 거의 사용할 일이 없다.
	// 스마트폰이 나오기 이전에도 자바로 휴대폰 게임을 개발했는데, 그때에는 메모리가 작았기 때문에 쓰레기 수집기의 실행 시기가 중요할 수도 있었다.
	// 새로운 화면을 만들기 위해 이전 화면에서 생성한 객체를 빨리 메모리에서 제거해야 했는데, 이때 System.gc()가 호풀되었다.
	
}
