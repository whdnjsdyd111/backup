package 챕터08_인터페이스;

public class ㄷ_Interface_Implement {
	
	// 개발 코드가 인터페이스 메소드를 호출하면 인터페이스는 객체의 메소드를 호출한다. 객체는 인터페이스에서 정의된 추상 메소드와 동일한 메소드 이름, 매개 타입, 리턴 타입을 가진 실체 메소드를 가지고 있어야 한다.
	// 이러한 객체를 인터페이스 구현 (implement) 객체라고 하고, 구현 객체를 생성하는 클래스를 구현 클래스라고 한다.
	
	//			메소드 호출				메소드 호출		(*구현 객체*)
	//		개발		→		인터페이스	 →			객체
	//		코드		←				 ←
	//			리턴 값				리턴값
	
			//	Implement Class		구현 클래스
	
	// 구현 클래스는 보통의 클래스와 동일한데, 인터페이스 타입으로 사용할 수 있음을 알려주기 위해 클래스 선언부에 implements 키워드를 추가하고 인터페이스명을 명시해야한다.
	
	//	public class 구현클래스명 implements 인터페이스명 {
	//		// 인터페이스에 선언된 추상 메소드의 실체 메소드 선언
	//	}
	
	// 그리고 인터페이스에 선언된 추상 메소드의 실체 메소드를 선언해야 한다. 다음은 Television과 Audio라는 이름을 가지고 있는 RemoteControl 구현 클래스를 작성하는 방법을 보여준다.
	// 클래스 선언부 끝에 implements RemoteControl이 붙어 있기 때문에 이 두 클래스는 RemoteControl 인터페이스로 사용이 가능하다.
	// RemoteControl에는 3개의 추상 메소드가 있기 때문에 Television과 Audio는 이 추상 메소드들에 대한 실체 메소드를 가지고 있어야 한다.
	
	// 구현 클레스에서 인터페이스의 추상 메소드들에 대한 실체 메소드를 작성할 때 주의할 점은 인터페이스의 모든 메소드는 기본적으로 public 접근 제한을 갖기 때문에 public보다 낮은 접근 제한으로 작성할 수 없다.
	// public을 생략하면 "Cannot reduce the visibility of the inherited method"라는 컴파일 에러를 만나게 된다.
	// 만약 인터페이스에 선언된 추상 메소드에 대응하는 실체 메소드를 구현 클래스가 작성하지 않으면 구현 클래스는 자동적으로 추상 클래스가 된다. 그렇기 때문에 클래스 선언부에 abstract 키워드를 추가해야 한다.
	
	//	public abstract class Television implements RemoteControl {
	//		public void turnOn() { ... }
	//		public void turnOff() { ... }	// setVolume() 실체 메소드가 없다 ( 일부만 구현 )
	//	}
	
	// 이클립스는 인터페이스의 추상 메소드에 대한 실체 메소드를 자동으로 생성해주는 기능을 제공하고 있다.
	// 코드 창에서 인터페이스를 implements한 이후 이클립스 메뉴에서 [ Source > Override / Implements Method... ] 를 선택하고 추상 메소드들을 체크한 후 [OK] 버튼을 클릭하면 실체 메소드들이 자동으로 생성된다.
	// 자동으로 생성된 실체 메소드는 @Override가 붙는데, @Override는 인터페이스의 추상 메소드에 대한 정확한 실체 메소드인지 컴파일러가 체크하도록 지시하는 어노테이션이다.
	// 생략해도 상관없지만, 잘못된 실체 메소드가 생기지 않도록 해주기 때문에 붙여주는 것이 좋다.
	
	// 구현 클래슥 작성되면 new 연산자로 객체를 생성할 수 있다. 문제는 어떤 타입의 변수에 대입하느냐이다. 다음과 같이 Television 객체를 생성하고 Television 변수에 대입한다고 인터페이스를 사용하는 것은 아니다.
	
	//	Television tv = new Television();	( x )
	
	// 인터페이스로 구현 객체를 사용하려면 다음과 같이 인터페이스 변수를 선언하고 구현 객체를 대입해야 한다. 인터페이스 변수는 참조 타입이기 때문에 구현 객체가 대입될 경우 구현 객체의 번지를 저장한다.
	
	//	인터페이스 변수;
	//	변수 = 구현 객체;				|		인터페이스 변수 = 구현 객체;
	
	// RemoteControl 인터페이스로 구현 객체인 Television과 Audio를 사용하려면 다음과 같이 RemoteControl 타입 변수 rc를 선언하고 구현 객체를 대입해야 한다.
	
			//	Anonymity Implements Object		익명 구현 객체
	
	// 구현 클래스를 만들어 사용하는 것이 일반적이고, 클래스를 재사용할 수 있기 때문에 편리하지만, 일회성의 구현 객체를 만들기 위해 소스 파일을 만들고 클래스를 선언하는 것은 비효율적이다.
	// 자바는 소스 파일을 만들지 않고도 구현 객체를 만들 수 있는 방법을 제공하는데. 그것이 익명 구현 객체이다.
	// 자바는 UI 프로그래밍에서 이벤트를 처리하기 위해, 그리고 암시 작업 스레드를 만들기 위해 익명 구현 객체를 많이 활용한다. 자바 8에서 지원하는 람다식은 인터페이스의 익명 구현 객체를 만들기 때문에 익명 구현 객체의 코드 패턴을 잘 익혀두길 바란다.
	// 다음은 익명 구현 객체를 생성해서 인터페이스 변수에 대입하는 코드이다. 작성 시 주의할 점은 하나의 실행문이므로 끝에는 세미콜론(;)을 반드시 붙여야 한다.
	
	//	인터페이스 변수 = new 인터페이스() {
	//		// 인터페이스에 선언된 추상 메소드의 실체 메소드 선언
	//	};
	
	// new 연산자 뒤에는 클래스 이름이 와야 하는데, 이름이 없다. 인터페이스() {}는 인터페이스를 구현해서 중괄호 {}와 같이 클래스를 선언하라는 뜻이고, new 연산자는 이렇게 선언된 클래스를 객체로 생성한다.
	// 중괄호 {}에는 인터페이스에 선언된 모든 추상 메소드들의 실체 메소드를 작성해야 한다. 그렇지 않으면 컴파일 에러가 발생한다.
	// 추가적으로 필드와 메소드를 선언할 수 있지만, 익명 객체 안에서만 사용할 수 있고 인터페이스 변수로 접근할 수 없다. 다음은 RemoteControl의 익명 구현 객체를 만들어 본것이다.
	
	// 모든 객체는 클래스로부터 생성되는데, 익명 구현 객체도 예외는 아니다. RemoteControlExample.java를 컴파일하면 자바 컴파일러에 의해 자동으로 다음과 같은 클래스 파일이 만들어진다.
	
	//	RemoteControlExample$1.class
	
	// RemoteControlExample 이름 뒤에 $가 붙고 생성 번호가 붙는데 생성 번호는 1번부터 시작한다.
	// 만약 두 번째 익명 구현 객체를 만들었다면 클래스 파일명은 RemoteControlExample$2.class가 된다.
	
			//	Multiple Interface Implements Class
	
	// 객체는 다음 그림과 같이 다수의 인터페이스 타입으로 사용할 수 있다.
	
	//				메소드  A 호출	인		메소드 A 호출
	//		개발			→		터			↘
	//		코드 A		←		페		↖
	//				리턴값		이	리턴값			
	//							스					객체
	//
	//				메소드 B 호출	인
	//		개발			→		터	메소드 B 호출
	//		코드 B		←		페		↗
	//				리턴값		이			↙
	//							스			리턴값
	
	// 인터페이스 A와 인터에픗 B가 객체의 메소드를 호출할 수 있으려면 객체는 이 두 인터페이스를 모두 구현해야 한다. 따라서 구현 클래스는 다음과 같이 작성되어야 한다.
	
	//	public class 구현클래스명 implements 인터페이스A, 인터페이스B {
	//		// 인터페이스 A에 선언된 추상 메소드의 실체 메소드 선언
	//		// 인터페이스 B에 선언된 추상 메소드의 실체 메소드 선언
	//	}
	
	// 다중 인터페이스를 구현할 경우, 구현 클래스는 모든 인터페이스의 추상 메소드에 대해 실체 메소드를 작성해야 한다. 만약 하나라도 없으면 추상 클래스로 선언해야 한다.
	// 다음은 인터넷을 검색할 수 있는 Searchable 인터페이스이다. search() 추상 메소드는 매개값으로 URL을 받는다.
	// 만약 SmartTelevision이 인터넷 검색 기능도 제공한다면 REmoteControl과 Searchable을 모두 구현해야한다.
}
