package 챕터08_인터페이스;

public class ㄴ_Declaration_Interface {
	
	// 인터페이스는 "~.java" 형태의 소스 파일로 작성되고 컴파일러(javac.exe)를 통해 "~.class" 형태로 컴파일되기 때문에 물리적 형태는 클래스와 동일하다.
	// 차이점은 소스를 작성할 때 선언하는 방법이 다르다
	
			// Interface Declaration	인터페이스 선언
	
	// 인터페이스 선언은 class 키워드 대신에 interface 키워드를 사용한다.
	
	// [ public ] interface 인터페이스명 { ... }
	
	// 인터페이스 이름은 클래스 이름을 작성하는 방법과 동일하다. 영어 대소문자를 구분하며, 첫 문자를 대문자로 하고 나머지는 소문자로 작성하는 것이 관례이다.
	// public 접근 제한은 다른 패키지에서도 인터페이스를 사용할 수 있도록 해준다. 이클립스에서 인터페이스를 생성하려면 Package Explorer 뷰에서 인터페이스를 포함할 패키지를 선택하고,
	// 메뉴에서 Interface를 생성하면 된다.
	
	//	public interface RemoteControl { }
	
	// 클래스는 필드, 생성자, 메소드를 구성 멤버로 가지는데 비해, 인터페이스는 상수와 메소드만을 구성 멤버로 가진다.
	// 인터페이스는 객체로 생성할 수 없기 때문에 생성자를 가질 수 없다. 자바 7 이전까지는 인터페이스의 메소드는 시랭 블록이 없는 추상 메소드로만 선언이 가능했지만, 자바 8부터는 디폴트 메소드와 정적 메소드도 선언이 가능하다.
	
	//	interface 인터페이스명 {
	//		// 상수
	//		타입 상수명 = 값;
	//
	//		// 추상 메소드
	//		타입 메소드명(매개변수, ...);
	//
	//		// 디폴트 메소드
	//		default 타입 메소드명(매개변수, ...);
	//
	//		// 정적 메소드
	//		static 타입 메소드명(매개변수, ...);
	//	}
	
	//		Constant Field		상수 필드
	
	// 인터페이스는 객체 사용 설명서이므로 런타임 시 데이터를 저장할 수 있는 필드를 선언할 수 없다.
	// 그러나 상수 필드는 선언이 가능하다. 상수는 인터페이스에 고정된 값으로 런타임시에 데이터를 바꿀 수 없다. 상수를 선언할 때에는 반드시 초기값을 대입해야 한다.
	
	//		Abstract Method		추상 메소드
	
	// 추상 메소드는 객체가 가지고 있는 메소드를 설명한 것으로 호출할 때 어떤 매개값이 필요하고, 리턴 타입이 무엇인지만 알려준다.
	// 실제 실행부는 객체(구현 객체)가 가지고 있다.
	
	//		Default Method		디폴트 메소드
	
	// 디폴트 메소드는 인터페이스에 선언되지만 사실은 객체(구현 객체)가 가지고 있는 인스턴스 메소드라고 생각해야 한다.
	// 자바 8에서 디폴트 메소드를 허용한 이유는 기존 인터페이스를 확장해서 새로운 기능을 추가하기 위해서이다.
	
	//		Static Method		정적 메소드
	
	// 정적 메소드도 역시 자바 8부터 작성할 수 있는데, 디폴트 메소드와는 달리 객체가 없어도 인터페이스만으로 호출이 가능하다.
	
			//	Constant Field Declaration		상수 필드 선언
	
	// 인터페이스는 데이터를 저장할 수 없기 때문에 데이터를 저장할 인스턴스 또는 정적 필드를 선언할 수 없다.
	// 대신 상수 필드만 선언할 수 있다. 상순ㄴ public static final로 선언하는데 클래스에서 이미 학습한 바 있다.
	// 따라서 인터페이스에 선언된 필드는 모두 public static final의 특성을 갖는다. public, static, final을 생략하더라도 자동적으로 컴파일 과정에서 붙게 된다.
	
	//	[ public static final ] 타입 상수명 = 값;
	
	// 상수명은 대문자로 작성하되, 서로 다른 단어로 구성될 경우엔 언더바(_)로 연결하는 것이 관례이다. 예를 들어  MODEL, MAX_VALUE와 같이 선언하면 된다.
	// 인터페이스 상수는 static {} 블록으로 초기화할 수 없기 때문에 반드시 선언과 동시에 초기값을 지정해야 한다.
	// 다음은 RemoteControl 인터페이스에 MAX_VALUE와 MIN_VALUE를 선언한 모습을 보여준다.
	
			// Abstract Method Declaration		추상 메소드 선언
	
	// 인터페이스를 통해 호출된 메소드는 최종적으로 객체에서 실행된다. 그렇기 때문에 인터페이스의 메소드는 실행 블록이 필요 없는 추상 메소드로 선언한다.
	// 추상 메소드는 리턴 타입, 메소드명, 매개 변수만 기술되고 중괄호 {}를 붙이지 않는 메소드를 말한다. 인터페이스에 선언된 추상 메소드는 모두 public abstract의 특성을 갖기 때문에 생략하더라도 자동적으로 컴파일 과정에서 붙게 된다.
		
	//			메소드 호출		인		메소드 호출
	//		개발		→		터	 	 →		객체		재정의된 메소드
	//		코드		←		페		 ←				(실제 실행 메소드)
	//			리턴 값		이		리턴값
	//						스		
	//					추상 메소드
	//					(메소드 선언부)
	//					(호출 방법만 기술)
	//						↓
	//		[public abstract] 리턴타입 메소드명(매개변수, ...);
	
	// 다음은 RemoteControl 인터페이스에서 turnOn(), turnOff(), setVolume() 추상 메소드를 선언했다.
	// 세 메소드는 모두 리턴 타입이 void 라는 것과 turnOn(), turnOff() 메소드는 호출 시 매개값이 필요없고, setVolume() 메소드만 int 매개값이 필요함을 알려주고 있다.
	
			// Default Method Declaration		디폴트 메소드 선언
	
	// 디폴트 메소드는 자바 8에서 추가된 인터페이스의 새로운 멤버이다. 형태는 클래스의 인스턴스 메소드와 동일한데, default 키워드가 리턴 타입 앞에 붙는다.
	// 디폴트 메소드는 public 특성을 갖기 때문에 public을 생략 하더라도 자동적으로 컴파일 과정에서 붙는다.
	
	//	[public] default 리턴타입 메소드명(매개변수, ...) { ... }
	
	// 다음은 RemoteControl 인터페이스에서 무음 처리 기능을 제공하는 setMute() 디폴트 메소드를 선언하였다.
	
			// Static Method Declaration	정적 메소드 선언
	
	// 정적 메소드는 디폴트 메소드와 마찬가지로 자바 8에서 추가된 인터페이스의 새로운 멤버이다. 형태는 클래스의 정적 메소드와 완전 동일하다.
	// 정적 메소드는 public 특성을 갖기 때문에 public을 생략하더라도 자동적으로 컴파일 과정에서 붙게 된다.
	
	//	[public] static 리턴타입 메소드명(매개변수, ...) {...}
	
	// 다음은 RemoteControl 인터페이스에서 밧데리를 교환하는 기능을 가진 changeBattery() 정적 메소드를 선언하였다.
}
