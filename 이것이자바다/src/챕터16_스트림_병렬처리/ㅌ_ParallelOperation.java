package 챕터16_스트림_병렬처리;

public class ㅌ_ParallelOperation {
	// 병렬 처리 (Parallel Operation)란 멀티 코어 CPU 환경에서 하나의 작업을 분할해서 각각의 코어가 병렬적으로 처리하는 것을 말하는데, 병렬 처리의 목적은 작업 처리 시간을 줄이기 위한 것이다.
	// 자바 8부터 요소를 병렬 처리할 수 있도록 하기 위해 병렬 스트림을 제공하기 때문에 컬렉션(배열)의 전체 요소 처리 시간을 줄여준다.
	
			//	Concurrency And Parallelism		동시성과 병렬성
	
	// 멀티 스레드는 동시성(Concurrency) 또는 병렬성(Parallelism)으로 실행되기 때문에 이 용어들에 대해 정확히 이해하는 것이 좋다.
	// 이 둘은 멀티 스레드의 동작 방식이라는 점에서는 동일하지만 서로 다른 목적을 가지고 있다.
	// 동시성은 멀티 작업을 위해 멀티 스레드가 번갈아가며 실행하는 성질을 말하고, 병렬성은 멀티 작업을 위해 멀티 코어를 이용해서 동시에 실행하는 성질을 말한다.
	// 싱글 코어 CPU를 이용한 멀티 작업은 병렬적으로 실행되는 것처럼 보이지만, 사실은 번갈아가며 실행하는 동시성 작업이다. 번갈아가며 실행하는 것이 워낙 빠르다보니 병렬성으로 보일 뿐이다.
	
	//		동시성(Concurrency)		병렬성(Parallelism)
	//
	//			Core 1				Core1	Core2
	//			  ↓					  │		  │
	//			작업 1				작업 1	작업 2
	//			  ↓
	//			작업2
	//			  ↓
	//			작업1					  ↓		  ↓
	//			  ↓
	
	// 병렬성은 데이터 병렬성(Data parallelism)과 작업 병렬성(Task parallelism)으로 구분할 수 있다.
	
			/*	Data Parallelism	데이터 병렬성	*/
	
	// 데이터 병렬성은 전체 데이터를 쪼개어 서브 데이터들로 만들고 이 서브 데이터들을 병렬 처리해서 작업을 빨리 끝내는 것을 말한다. 자바 8에서 지원하는 병렬 스트림은 데이터 병렬성을 구현한 것이다.
	// 멀티 코어의 수만큼 대용량 요소를 서브 요소들로 나누고, 각각의 서브 요소들을 분리된 스레드에서 병렬 처리시킨다. 예를 들어 쿼드 코어(Quad Core) CPU일 경우 4개의 서브 요소들로 나누고,
	// 4개의 스레드가 각각의 요소들을 병렬 처리한다.
	
			/*	Task Parallelism	작업 병렬성		*/
	
	// 작업 병렬성은 서로 다른 작업을 병렬 처리하는 것을 말한다. 작업 병렬성의 대표적인 예는 웹 서버(Web Server)이다. 웹 서버는 각각의 브라우저에서 요청한 내용을 개별 스레드에서 병렬로 처리한다.
	
			//	ForkJoin Framework		포크조인 프레임워크
	
	// 병렬 스트림은 요소들을 병렬 처리하기 위해 포크조인(ForkJoin) 프레임워크(Framework)를 사용한다. 
	// 병렬 스트림을 이용하면 런타임 시에 포크조인 프레임워크가 동작하는데, 포크 단계에서는 전체 데이터를 서브데이터로 분리한다. 그리고 나서 서브 데이터를 멀티 코어에서 병렬로 처리한다.
	// 조인 단계에서는 서브 결과를 결합해서 최종 결과를 만들어 낸다. 예들 들어 쿼드 코어 CPU에서 병렬 스트림으로 작업을 처리할 경우, 스트림의 요소를 N개라고 보았을 때 포크 단계에서는 전체 요소를 4등분 한다.
	// 그리고 1등분씩 개별 코어에서 처리하고 조인 단계에서는 3번의 결합 과정을 거쳐 최종 결과를 산출한다.
	
	//	F							요소	1	..	N
	//	O				요소 1  ..  1/N					요소	1/N  ..  N
	//	R		요소 1 .. 1/4N	요소 1/4N .. 1/2N		요소 1/2N .. 3/4N		요소 3/4N .. N
	//	K
	//			Core1↓				Core2↓				Core3↓				Core4↓
	//				작업 결과				작업 결과				작업 결과				작업 결과
	//					↘					↙					↘					↙
	//	J						부분 결합									부분 결합
	//	O							↘									↙
	//	I											최종 결합
	//	N
	
	// 병렬 처리 스트림은 실제로 포크 단계에서 차례대로 요소를 4등분하지 않는다. 이해하기 쉽도록 하기 위해 위와 같이 차례대로 4등분했지만, 내부적으로 서브 요소를 나누는 알고리즘이 있다.
	// 포크조인 프레임워크는 포크와 조인 기능 이외에  스레드풀인 ForkJoinPool을 제공한다. 각각의 코어에서 서브 요소를 처리하는 것은 개별 스레드가 해야 하므로 스레드 관리가 필요하다.
	// 포크조인 프레임워크는 ExecutorService의 구현 객체인 ForkJoinPool을 사용해서 작업 스레드를 관리한다.
	
	//	스레드풀(ExecutorService)
	//										스레드1							┐
	//		요소 1 .. 1/4N		→			작업 처리			→		Core1	│
	//										  ■								│	최
	//																		│	대
	//										스레드2							│	개
	//		요소 1/4N .. 2/4N		→			작업 처리			→		Core2	│	수
	//										  ■								│	
	//																		│	제	
	//										스레드3							│	한
	//		요소 2/4N .. 3/4N		→			작업 처리			→		Core3	│
	//										  ■								│
	//																		│
	//										스레드4							│
	//		요소 3/4N .. N		→			작업 처리			→		Core4	│
	//										  ■								┘
	
	// 병렬 처리를 위해 코드에서 포크조인 프레임워크를 직접 사용할 수는 있지만, 병렬 스트림을 이용할 경우에는 백그라운드에서 포크조인 프레임워크가 사용되기 때문에 개발자는 매우 쉽게 병렬 처리를 할 수 있다.
	// 병렬 스트림은 다음 두 가지 메소드로 얻을 수 있다.
	
	//	인터페이스							리턴 타입			메소드(매개 변수)
	//
	//	java.util.Collection			Stream			parallelStream()
	//
	//	java.util.Stream.Stream			Stream
	//	java.util.Stream.IntStream		IntStream
	//	java.util.Stream.LongStream		LongStream		parallel()
	//	java.util.Stream.DoubleStream	DoubleStream
	
	// parallelStream() 메소드는 컬렉션으로부터 병렬 스트림을 바로 리턴한다. parallel() 메소드는 순차 처리 스트림을 병렬 처리 스트림으로 변환해서 리턴한다. 
	// 어떤 방법으로 병렬 스트림을 얻더라도 이후 요소 처리 과정은 병렬 처리돤다. 내부적으로 전체 요소를 서브 요소들로 나누고, 이 서브 요소들을 개별 스레드가 처리한다.
	// 서브 처리 결과가 나오면 결합해서 마지막으로 최종 처리 결과를 리턴한다. 내부적인 동작을 확인하려면 16.11.2 자용자 정의 컨테이너에 수집하기에서 살펴본 예제를 병렬 스트림으로 수정해서 실행해보면 된다.
	// 먼저 수정 전의 코드를 보자.
	
	//	MaleStudent maleStudent = totalList.stream()
	//		.filter( s -> s.getSex() == Student.Sex.MALE)
	//		.collect(MaleStudent :: new, MaleStudent :: accumulate, MaleStudent :: combine);
	
	// 전체 학생 목록에서 stream() 메소드로 순차 처리 스트림을 얻었기 때문에 MaleStudent 객체는 하나만 생성되고, 남학생을 MaleStudent에 수집하기 위해 accumulate()가 호출된다.
	// combine() 메소드는 전혀 호출되지 않았는데, 그 이유는 순차 처리 스트림이므로 결합할 서브 작업이 없기 때문이다. 이 코드를 병렬 처리 스트림으로 변경하면 다음과 같다.
	
	//	MaleStudent maleStudent = totalList.parallelStream()
	//		.filter( s -> s.getSex() == Student.Sex.MALE)
	//		.collect(MaleStudent :: new, MaleStudent :: accumulate, MaleStudent :: combine);
	
	// 단순히 stream() 메소드 호출이 parallelStream() 메소드 호출로 변경되었지만 내부 동작은 다음과 같은 순서로 전혀 다르게 진행된다.
	
	// 1 쿼드 코어 CPU에서 실행된다면 전체 요소는 4개의 서브 요소로 나눠지고, 4개의 스레드가 병렬 처리한다.
	// 각 스레드는 서브요소를 수집해야 하므로 4개의 MaleStudent 객체를 생성하기 위해 collect()의 첫 번째 메소드 참조인 MaleStudent :: new를 4번 실행시킨다.
	
	// 2 각 스레드는 MaleStudent 객체에 남학생 요소를 수집하기 위해 두 번째 메소드 참조인 MaleStudent :: accumulate를 매번 실행시킨다.
	
	// 3 수집이 완료된 4개의 MaleStudent는 3번의 결합으로 최종 MaleStudent가 만들어질 수 있으므로 세 번째 메소드 참조인 MaleStudent :: combine이 3번 실행된다.
	
	// 예제의 결과를 보면 main 스레드와 ForkJoinPool에서 3개의 스레드가 사용되어 총 4개의 스레드가 동작한다. 이것은 필자의 컴퓨터가 쿼드 코어 CPU를 사용하기 때문이다.
	// 각각의 스레드가 하나의 서브 작업이라고 본다면 총 4개의 서브 작업으로 분리되었다고 생각하면 된다. 
	// 각 서브 작업은 남학생을 누락시킬 MaleStudent 객체를 별도로 생성하기 때문에 MaleStudent() 생성자가 4번 실행되었다.
	// 하지만 전체 학생 중에서 남학생이 2명 밖에 없으므로 accumulate()는 2번밖에 호출되지 않았다.
	// 누적이 완료된 4개의 MaleStudent 객체는 3번의 결합으로 최종 maleStudent가 만들어 지므로 combine() 메소드가 3번 호출되었다.
	
	//		MS1	┐
	//			│ combine()
	//		  +	│	MS1	────┐
	//			│			│
	//		MS2	┘			│  combine()
	//					  +	│	MS1
	//		MS3	┐			│
	//			│ combine()	│
	//		  +	│	MS3	────┘
	//			│
	//		MS4	┘
	
	// 학생 수를 100명으로 늘리고 쿼드 코어 CPU에서 테스트하면 4개의 코어가 병렬적으로 요소를 처리하고 있는 모습을 볼 수 있다.
	
			//	Parallel Handling Performance		병렬 처리 성능
	
	// 스트림병렬 처리가 스트림 순차 처리보다 항상 실행성능이 좋다고 판단해서는 안 된다. 병렬 처리에 영향을 미치는 다음 3가지 요인을 잘 살펴보아야한다.
	
			/*	Number Of Elements And Processing Time Per Elements		요소의 수와 요소 당 처리 시간	*/
	
	// 컬렉션에 요소의 수가 적고 요소 당 처리 시간이 짧으면 순차 처리가 오히려 병렬 처리보다 빠를 수 있다. 병렬 처리는 스레드풀 생성, 스레드 생성이라는 추가적인 비용이 발생하기 때문이다.
	
			/*	Kind Of Stream Source	스트림 소스의 종류		*/
	
	// ArrayList, 배열은 인덱스로 요소를 관리하기 때문에 포크 단계에서 요소를 쉽게 분리할 수 있어 병렬 처리 시간이 절약된다.
	// 반면에 HashSet, TreeSet은 요소 분리가 쉽지 않고, LinkedList 역시 링크를 따라가야 하므로 요소 분리가 쉽지 않다. 따라서 이 소스들은 ArrayList, 배열보다는 상대적으로 병렬 처리가 늦다.
	
			/*	Number Of Core		코어의 수	*/
	
	// 싱글 코어 CPU일 경우에는 순차 처리가 빠르다. 병렬 스트림을 사용할 경우 스레드의 수만 증가하고 동시성 작업으로 처리되기 때문에 좋지 못한 결과를 준다.
	// 코어의 수가 많으면 많을수록 병렬 작업 처리 속도는 빨라진다.
	
	// 다음 예제는 work() 메소드의 실행 시간(요소 당 처리 시간)을 조정함으로써 순차 처리와 병렬 처리 중 어떤 것이 전체 요소를 빨리 처리하는지 테스트한다.
	
	// 이 예제의 실행 결과는 work()의 요소 처리 시간에 따라 달라진다. 필자가 진행해본 결과 Thread.sleep(10)으로 실행하면 순차 처리가 더 빨랐다. 
	// 그렇기 때문에 실제 작업 내용을 작성한 후에는 순차 처리와 병렬 처리 중 어떤 처리가 유리한지 테스트해보아야한다. 
	// 다음 예제는 스트림 소스가 ArrayList인 경우와 LinkedList일 경우 대용량 데이터의 병렬 처리 성능을 테스트한 것이다. 백만 개의 Integer 객체를 각각 ArrayList와 LinkedList에 저장하고 테스트하였다.
	
	// 실행 결과 ArrayList가 빠른 실행 성능을 보였다. 하지만 요소의 개수가 적을 경우에는 LinkedList가 더 빠른 성능을 보였다. 워밍업을 둔 이유는 실행 준비 과정에서 오차를 줄이기 위해서이다.
}	
