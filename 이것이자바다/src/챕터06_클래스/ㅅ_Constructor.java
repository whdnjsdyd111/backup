package 챕터06_클래스;

public class ㅅ_Constructor {
	// 생성자는 new 연산자와 같이 사용되어 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당한다.
	// 객체 초기화란 필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 하는 것을 말한다.
	// 생성자를 실행시키지 않고는 클래스로부터 객체를 만들 수 없다. new 연산자에 의해 생성자가 성공적으로 실행되면 힙 영역에 객체가 생성되고 객체의 주소가 리턴된다.
	// 리턴된 객체의 주소는 클래스 타입 변수에 저장되어 객체에 접글할 때 이용된다. 만약 생성자가 성공적이지 않아 예외(에러)가 발생했다면 객체는 생성되지 않는다.
	
		// Default Constructor 기본 생성자
	
	// 모든 클래스는 생성자가 반드시 존재하며, 하나 이상을 가질 수 있다. 우리가 클래스 내부에 생성자를 생략했다면 컴파일러는 다음과 같이 중괄호 {} 블록이 빈 기본 생성자(Default Constructor)를 자동 추가시킨다.
	
	// [public] 클래스() {}
	
	// 클래스가 public class로 선언되면 기본 셍성자 또한 public 이 붙지만 클래스가 public 없이 class로만 선언되면 기본 생성자에도 public이 붙지 않는다.
	
	//	public class Car{		|		public class Car{
	//							|			public Car() {} // 자동추가
	//	}						|		}
	
	// 그렇기 때문에 클래스를 생성할때 new 연산자 뒤에 호출할 수 있다.
	
	// 하지만 명시적으로 선언한 생성자가 한 개라도 있으면, 컴파일러는 기본 생성자를 추가하지 않는다.
	// 명시적으로 생성자를 선언하는 이유는 객체를 다양하게 초기화하기 위해서이다.
	
		// Constructor Declaration 생성자 선언 
	
	// 기본 생성자 대신 우리가 생성자를 명시적으로 선언하려면 다음과 같은 형태로 작성하면 된다.
	
	// 클래스( 매개변수선언, ... ) {
	//		// 객체의 초기화 코드
	//	}
	
	// 생성자는 메소드와 비슷한 모양이지만 리턴 타입이 없고 클래스 이름과 동일하다.
	// 생성자 블록 내부에는 객체 초기화 코드가 작성되는데, 일반적으로 필드에 초기값을 저장하거나 메소드를 호출하여 객체 사용전에 필요한 준비를 한다.
	// 매개 변수 선언은 생략할 수도 있고, 여러 개를 선언해도 좋다. 매개 변수는 new 연산자로 생성자를 호출할 때 외부의 값을 생성자 블록 내부로 전달하는 역할을 한다.
	
	// 생성자 생성 에제 Car을 살펴보자.
	
		// Field Initialization 필드 초기화 
	
	// 클래스부터 객체가 생성될 때 필드는 초기값으로 자동설정 된다. 만약 다른 값으로 초기화를 하고 싶다면 두 가지 방법이 있다.
	// 하나는 필드를 선언할 때 초기값을 주는 방법이고, 다른 하나는 생성자에서 초기값을 주는 방법이다.
	// 필드를 선언할 때 초기값을 주게되면 동일한 클래스로부터 생성되는 객체들은 모두 같은 데이터를 갖게된다. 물론 생성 후 변경할 수 있지만 생성 시점에서는 필드의 값이 모두 값다.
	// 하지만 객체 생성 시점에 외부에서 제공되는 다양한 값들로 초기화해야 한다면 생성자에서 초기화 해야한다.
	// 예로 이름이나 주민번호 필드값이 있다하면, 클래스를 작성할 때 초기값을 줄 수 없고 객체 생성 시점에서 다양한 값을 가져야 한다.
	
	// 예로 필드 초기화 예제 Korean
	
	// korean 생성자의 매개 변수 이름은 각각 n과 s를 사용했다. 매개 변수의 이름이 너무 짧으면 가독성이 좋지 않아 가능성 필드 이름과 비슷하거나 동일한 이름을 사용할 것을 권한다.
	// 관례적으로 필드와 동일한 이름을 갖는 매개 변수를 사용한다. 이 경우 필드와 매개 변수 이름이 동일하기 때문에 생성자 내부에서 해당 필드에 접근할 수 없다. 왜냐면 동일한 이름의 매개 변수가 사용 우선순위가 높기 때문이다.
	// 해결 방법은 필드 앞에 'this.'를 붙이면 된다. this는 객체 자신의 참조인데, this라는 참조 변수로 필드를 사용하는 것과 동일해 진다.
	
	//	public Korean(String name, String ssn) {
	//		this.name = name;
	//		this.ssn = ssn;
	//	}
	
	// 객체의 필드는 하나가 아니라 여러 개가 있고, 이 필드들은 모두 생성자에서 초기화한다면 생성자의 매개 변수의 수는 객체의 필드 수만큼 선언되어야 한다.
	// 그러나 실제로 중요한 몇개 필드만 매개변수를 통해 초기화되고 나머지 필드들은 필드 선언 시에 초기화하거나 생성자 내부에서 임의값 또는 계산된 값으로 초기화한다. 아니면 객체 생성 후에 필드값을 별도로 저장하기도 한다.
	
		// Overloading 생성자 오버로딩
	
	// 외부에서 제공되는 다양한 데이터들을 이용해서 객체를 초기화하려면 생성자도 다양화될 필요가 있다.
	// Car 객체를 생성할 때 외부에서 제공되는 데이터가 없다면 기본 생성자로 Car 객체를 생성해야하고, 외부에서 model 데이터가 제공되거나 model과 color가 제공돨 경우도 Car 객체를 생성할 수 있어야 한다.
	// 생성자가 하나뿐이라면 이러한 요구 조건을 수용할 수 없다. 그래서 자바는 다양한 방법으로 객체를 생성할 수 있도록 생성자 오버로딩을 제공한다. 생성자 오버로딩이란 매개 변수를 달리하는 생성자를 여러 개 선언한 것이다.
	
	//	public class 클래스 {
	//		클래스 ( [타입 매개변수, ...] ) {
	//			..
	//		}
	//
	//		클래스 ( [타입 매개변수, ...] ) {
	//			..
	//		}
	//	}
	
	// 다음은 Car 클래스에서 생성자를 오버로딩한 예를 보여준다.
	
	//	public class Car {
	//		Car() { ... }
	//		Car(String model) { ... }
	//		Car(String model, String color) { ... }
	//		Car(String model, String color, int maxSpeed) { ... }
	//	}
	
	// 생성자 오버로딩 시 주의할 점은 매개 변수의 타입 개수와 선언된 수서가 똑같을 경우 매개 변수만 바꾸는 것은 생성자 오버로딩이라 볼 수 없다. 다음과 같다.
	
	//	Car(String model, String color) { ... }
	//	Car(String color, String model) { ... } // 오버로딩이 아님
	
	// 생성자가 오버로딩되어 있을 경우, new 연산자로 생성자를 호출할 때 제공되는 매개값의 타입과 수에 의해 호출될 생성자가 결정된다. 다음은 다양한 방법으로 Car 객체를 생성한다.
	
	//	Car car1 = new Car();
	//	Car car2 = new Car("그랜저");
	//	Car car3 = new Car("그랜저", "흰색");
	//	Car car4 = new Car("그랜저", "흰색", 300);
	
	// Car 생성자를 오버로딩해서 CarExample 클래스에서 다양한 방법으로 Car 객체를 생성하는 예제를 살펴보자
}
