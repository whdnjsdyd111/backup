package 챕터15_컬렉션프레임워크;

public class ㅂ_LIFO_FIFO {
	// 후입선출(LIFO : Last In First Out)은 나중에 넣은 객체가 먼저 빠져나가는 자료구조를 말한다.
	// 반대로 선입선출(FIFO : First In First Out)은 먼저 넣은 객체가 먼저 빠져나가는 구조를 말한다.
	// 컬렉션 프레임워크에는 LIFO 자료구조를 제공하는 스택(stack) 클래스와 FIFO 자료구조를 제공하는 큐(Queue) 인터페이스를 제공하고 있다. 다음은 스택과 큐의 구조이다.
	
	//
	//	넣기 ↘	↗ 빼기
	//	(push)	  (pop)									Last		First
	//		│	│										ㅣ			ㅣ
	//		│ 3	│	-	last							──────────────
	//		│ 2	│						(offer) 넣기	→	5  4  3  2  1	→	빼기 (poll)
	//		│ 1	│	-	first							──────────────
	//		└───┘
	//	스택 ( LIFO )										큐 ( FIFO )
	
	// 스택 (Stack)을 응용한 대표적인 예가 JVM 스택 메모리이다. 스택 메모리에 저장된 변수는 나중에 저장된 것부터 제거된다.
	//	큐 (Queue)를 응용한 대표적인 예가 스레드풀(ExecutorService)의 작업 큐이다. 작업 큐는 먼저 들어온 작업부터 처리한다.
	
			//	Stack
	
	// Stack 클래스는 LIFO 자료구조를 구현한 클래스이다. 다음은 Stack 클래스의 주요 메소드들이다.
	
	//	리턴 타입	메소드			설명
	//		
	//	E		push(E item)	주어진 객체를 스택에 넣는다.
	//	E		peek()			스택의 맨 위 객체를 가져온다. 객체를 스택에서 제거하지 않는다.
	//	E		pop()			스택의 맨 위 객체를 가져온다. 객체를 스택에서 제거한다.
	
	// Stack 객체를 생성하기 위해서는 저장할 객체 타입을 파라미터로 표기하고 기본 생성자를 호출하면 된다.
	
	//	Stack<E> stack = new Stack<E>();
	
	// 다음은 택시에서 많이 볼 수 있는 동전케이스를 Stack 클래스로 구현한 예제이다.
	// 동전케이스는 위에만 오픈되어 있는 스택 구조를 가지고 있다. 먼저 넣은 동전은 제일 밑에 깔리고 나중에 넣은 동전이 위에 쌓이기 때문에 Stack에서 동전을 빼면 마지막에 넣은 동전이 먼저 나온다.
	
			//	Queue
	
	// Queue 인터페이스는 FIFO 자료구조에서 사용되는 메소드를 정의하고 있다. 다음은 Queue 인터페이스에 정의되어 있는 메소드를 보여준다.
	
	//	리턴 타입		메소드			설명
	//
	//	boolean		offer(E e)		주어진 객체를 넣는다.
	//	E			peek()			객체 하나를 가져온다. 객체를 큐에서 제거하지 않는다.
	//	E			poll()			객체 하나를 가져온다. 객체를 큐에서 제거한다.
	
	// Queue 인터페이스를 구현한 대표적인 클래스는 LinkedList이다. LinkedList는 List 인터페이스를 구현했기 때문에 List 컬렉션이기도 하다.
	// 다음 코드는 LinkedList 객체를 Queue 인터페이스 타입으로 변환한 것이다.
	
	//	Queue<E> queue = new LinkedList<E>();
	
	// 다음은 Queue를 이용해서 간단한 메세지 큐를 구현한 예제이다. 먼저 넣은 메세지가 반대쪽으로 먼저 나오가 땨문에 넣은 순서대로 메세지가 처리된다.
	
}
