package 챕터09_중첩클래스_중첩인터페이스;

public class ㄷ_AccessModifierOfNestedClass {
			//	Outside Field And Usage Limit On Method		바깥 필드와 메소드에서 사용 제한
	
	// 멤버 클래스가 인스턴스 또는 정적으로 선언됨에 따라 바깥 클래스의 필드와 메소드에 사용 제한이 생긴다. 다음 예제를 살펴보면 알 수 있다.
	// 인스턴스 멤버 클래스(B)는 바깥 클래스의 인스턴스 필드(field1)의 초기값이나 인스턴스 메소드(method1())에서 객체를 생성할 수 있으나, 정적 필드(field3)의 초기값이나 정적 메소드(method2())에서는 객체를 생성할 수 없다.
	// 반면 정적 멤버 클래스(C)는 모든 필드의 초기값이나 모든 메소드에서 객체를 생성할 수 있다.
	
			//	Usage Limit On Member Class		멤버 클래스에서 사용 제한
	
	// 멤버 클래스가 인스턴스 또는 정적으로 선언됨에 따라 멤버 클래스 내부에서 바깥 클래스의 필드와 메소드를 접근할 때에도 제한이 따른다.
	// 인스턴스 멤버 클래스(B) 안에서는 바깥 클래스의 모든 필드와 모든 메소드에 접근할 수 있지만, 정적 멤버 클래스(C)안에서는 바깥 클래스의 정적 필드와 메소드에만 접근할 수 있고 인스턴스 필드와 메소드는 접근할 수 없다.
	
	//	class A {							|		class A {
	//										|		
	//		int field1;						|			int field1;
	//		void method1() {...}			|			void method1() {...}
	//										|		
	//		static int field2;				|			static int field2;
	//		static void method2() {...}		|			static void method2() {...}
	//										|		
	//		class B {						|			static class C {
	//			void method() {				|				void method() {
	//				field1 = 10;			|					// field1 = 10;
	//				method1();				|					// method1();
	//										|		
	//				field2 = 10;			|					field2 = 10;
	//				method2();				|					method2();
	//			}							|				}
	//		}								|			}
	//	}									|		}
	//	
	
	//	예제로 다시 한번 더 살펴 보자.
	
			// Usage Limit On Local Class		로컬 클래스에서 사용 제한
	
	// 로컬 클래스 내부에서는 바깥 클래스의 필드나 메소드 제한 없이 사용할 수 있다. 문제는 메소드의 매개 변수나 로컬 변수를 로컬 클래스에서 사용할 때이다.
	// 로컬 클래스의 객체는 메소드 실행이 끝나도 힙 메모리에 존재해서 계속 사용할 수 있다. 매개 변수나 로컬 변수는 메소드 실행이 끝나면 스택 메모리에서 사라지기 때문에 로컬 객체에서 사용할 경우 문제가 발생한다.
	// 자바는 이 문제를 해결하기 위해 컴파일 시 로컬 클래스에서 사용하는 매개 변수나 로컬 변수의 값을 로컬 클래스 내부에 복사해 두고 사용한다. 그리고 매개 변수나 로컬 변수가 수정되어 값이 변경되면
	// 로컬 클래스에 복사해 둔 값과 달라지는 문제를 해결하기 위해 매개 변수나 로컬 변수를 final로 선언해서 수정을 막는다.
	// 결론적으로 말해서 로컬 클래스에서 사용 가능한 것은 final로 선언된 매개 변수와 로컬 변수뿐이라는 것이다. 자바 7 이전까지는 final 키워드 없이 선언된 매개 변수나 로컬 변수를 로컬 클래스에서 사용하면 컴파일 에러가 발생했다.
	// 하지만 자바 8 부터는 final 키워드 없이 선언된 매개 변수와 로컬 변수를 사용해도 컴파일 에러가 발생하지 않는다. 그렇다면 자바 8 부터는 final이 아닌 배개 변수와 로컬 변수를 허용한다는 것일까?
	// 당연히 아니다. final 선언을 하지 않아도 여전히 값을 수정할 수 없는 final 특성을 갖는다는 것이다. final 키워드 존재 여부의 차이점은 로컬 클래스의 복사 위치이다.
	// final 키워드가 있다면 로컬 클래스의 메소드 내부에 지역 변수로 복사되지만, final 키워드가 없다면 로컬 클래스의 필드로 복사된다.
	
	//	void outMethod( final int arg1, int arg2 ) {			class LocalClass {
	//																int arg2 = 매개값;
	//		final int var1 = 1;										int var2 = 2;		// 필드로 복사
	//		int var2 = 2;										
	//														→		void method() {
	//		class LocalClass {											int arg1 = 매개값;
	//			void method() {											int var1 = 1;		// 로컬 변수로 복사
	//				int result = arg1 + arg2 + var1 + var2;		
	//			}														int result = arg1 + arg2 + var1 + var2;
	//		}														}
	//	}														}
	
	// 우리는 로컬 클래스의 내부 복사 위치에 신경 쓸 필요 없이 로컬 클래스에서 사용된 매개 변수와 로컬 변수는 모두 final 특성을 갖는다는 것만 알면 된다.
	// 다음 예제는 매개 변수와 로컬 변수가 로컬 클래스에서 사용할 때 final 특성을 갖고 있음을 잘 보여준다. 자바 7 까지는 반드시 final 키워드를 붙여야 하지만, 자바 8 부터는 붙이지 않아도 final 특성을 가지고 있음을 주목해야 한다.
	
			//	Getting Reference Of Outside Class On Nested Class		중첩 클래스에서 바깥 클래스 참조 얻기
	
	// 클래스 내부에서 this는 객체 자신의 참조이다. 중첩 클래스에서 this 키워드를 사용하면 바깥 클래스의 객체 참조가 아니라, 중첩 클래스의 객체 참조가 된다.
	// 따라서 중첩 클래스 내부에서 this.필드, this.메소드()로 호출하면 중첩 클래스의 필드와 메소드가 사용된다.
	// 중첩 클래스 내부에서 바깥 클래스의 객체를 참조를 얻으려면 바깥 클래스의 이름을 this 앞에 붙여주면 된다. 다음은 바깥 클래스의 필드와 메소드에 접근하기 위해 바깥클래스.this를 사용한 예이다.
	
	//	바깥클래스.this.필드;
	//	바깥클래스.this.메소드();
	
	// 다음 예제를 살펴보자.
	
}
