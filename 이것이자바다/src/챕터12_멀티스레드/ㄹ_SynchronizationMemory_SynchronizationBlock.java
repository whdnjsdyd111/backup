package 챕터12_멀티스레드;

public class ㄹ_SynchronizationMemory_SynchronizationBlock {
			//	Caveat When Using Shared Objects	공유 객체를 사용할 때의 주의할 점
	
	// 싱글 스레드 프로그램에서는 한 개의 스레드가 객체를 독차지해서 사용하면 되지만, 멀티 스레드 프로그램에서는 스레드들이 객체를 공유해서 작업해야 하는 경우가 있다.
	// 이 경우, 스레드 A를 사용하던 객체가 스레드 B에 의해 상태가 변경될 수 있기 때문에 스레드 A가 의도했던 것과는 다른 결과를 산출할 수도 있다.
	// 이는 마치 여러 사람이 계산기를 함께 나눠 쓰는 상황과 같아서 사람 A가 계산기로 작업을 하다가 계산 결과를 메모리에 저장한 뒤 잠시 자리를 비웠을 때 
	// 사람 B가 계산기를 만져서 앞 사람이 메모리에 저장한 값을 다른 값으로 변경하는 것과 같다.
	// 그런 다음 사람 A가 돌아와 계산기에 저장된 값을 이용해서 작업을 실행한다면 결국 사람 A는 엉터리 값을 이용하게 된다. 다음 예를 보며 이해하자.
	
	//	User1 스레드
	//
	//	↓	memory = 100;  1↓		
	//							
	//		2초간 					2↓	memory = 50;	↓
	//		일시정지				
	//									2초간
	//	↓	출력	3↓						일시정지
	//
	//					memory		4←	출력				↓
	//					필드
	
	// User1 스레드가 Calculator 객체의 memory 필드에 100을 먼저 저장하고 2초간 일시 정지 상태가 된다.
	// 그동안에 User2 스레드가 memory 필드값에 50으로 변경한다. 2초가 지나 User1 스레드가 다시 실행 상태가 되어 memory 필드의 값을 출력하면 User2가 저장한 50이 나온다.
	// 그럼 예제를 살펴보자.
	
			// Synchronized Method And Synchronized Block
	
	// 스레드가 사용 중인 객체를 다른 스레드가 변경할 수 없도록 스레드 작업이 끝날 때까지 객체에 잠금을 걸어서 다른 스레드가 사용할 수 없도록 해야 한다.
	// 멀티 스레드 프로그램에서 단 하나의 스레드만 실행할 수 있는 코드 영역을 임계 영역(critical section)이라고 한다.
	// 자바는 임계 영역을 지정하기 위해 동기화(synchronized) 메소드와 동기화 블록을 제공한다.
	// 스레드가 객체 내부의 동기화 메소드 또는 블록에 들어가면 즉시 객체에 잠금을 걸어 다른 스레드가 임계 영역 코드를 실행하지 못하도록 한다.
	// 동기화 메소드를 만드는 방법은 다음과 같이 메소드 선언에 synchronized 키워드를 붙이면 된다. synchronized 키워드는 인스턴스와 정적 메소드 어디든 붙일 수 있다.
	
	//	public synchronized void method() {
	//		임계 영역; // 단 하나의 스레드만 실행
	//	}
	
	// 동기화 메소드는 메소드 전체 내용이 임계 영역이므로 스레드가 동기화 메소드를 실행하는 즉시 객체에는 잠금이 일어나고, 스레드가 동기화 메소드를 실행 종료하면 잠금이 풀린다.
	// 메소드 전체 내용이 아니라, 일부 내용만 임계 영역으로 만들고 싶다면 다음과 같이 동기화(synchronized) 블록을 만들면 된다.
	
	//	public void method() {
	//		// 여러 스레드가 실행 가능 영역
	//		...
	//		synchronized(공유객체) {
	//			임계 영역; // 단 하나의 스레드만 실행
	//		}
	//		
	//		// 여러 스레드가 실행 가능 영역
	//		...
	//	}
	
	// 동기화 블록의 외부 코드들은 여러 스레드가 동시에 실행할 수 있지만, 동기화 블록의 내부 코드는 임계 영역이므로 한 번에 한 스레드만 실행할 수 있고 다른 스레드는 실행할 수 없다.
	// 만약 동기화 메소드와 동기화 블록이 여러 개 있을 경우, 스레드가 이들 중 하나를 실행할 때 다른 스레드는 해당 메소드는 물론이고 다른 동기화 메소드 및 블록도 실행할 수 없다. 하지만 일반 메소드는 가능하다.
	// 다음 예제는 이전 예제에서 문제가 된 공유 객체인 Calculator를 수정한 것이다.
	// Calculator의 setMemory() 메소드를 동기화 메소드로 만들어서 User1 스레드가 setMemory()를 실행할 동안 User2 스레드가 setMemory() 메소드를 실행할 수 없도록 했다.
	
	// 예제를 실행해보면 User1은 100, User2는 50이라는 출력값을 얻는데, 다음을 보며 이해해보자.
	
	//	User1 스레드
	//
	//	↓	memory = 100;  1↓		
	//							
	//		2초간 					
	//		일시정지				
	//								
	//	↓	출력	2↓						
	//
	//					memory		
	//					필드
	//								3↓	memory = 50;	↓
	//
	//									2초간
	//									일시정지
	//
	//									4↓	출력				↓
	
	// User1 스레드는 Calculator 객체의 동기화 메소드인 setMemory()를 실행하는 순간 Calculator 객체를 잠근다.
	// 메인 스레드가 User2 스레드를 실행시키지만, 동기화 메소드인 setMemory()를 실행시키지는 못하고 User1이 setMemory()를 모두 실행할 동안 대기해야 한다.
	// User1 스레드가 setMemory() 메소드를 모두 실행하고 나면 User2 스레드가 setMemory() 메소드를 실행한다.
	// 결국 User1 스레드가 Calculator 객체를 사용할 동안 User2 스레드는 Calculator 객체를 사용하지 못하므로 User1 스레드는 안전하게 방해받지 않고 Calculator 객체를 사용할 수 있게 된다.
	// 위 예제에서는 Calculator 객체의 setMemory() 메모리를 동기화 메소드로 만들었는데, 다음과 같이 동기화 블록으로도 만들 수 있다.
	
	//	public void setMemory(int memory) {
	//		synchronized(this) {			// 공유 객체인 Calculator의 참조(잠금 대상)
	//			this.memory = memory;
	//	
	//			try {
	//				Thread.sleep(2000);		
	//			} catch (Exception e) {
	//				// TODO: handle exception
	//			}
	//			System.out.println(Thread.currentThread().getName() + ": " + this.memory);
	// 		}
	//	}
	
	// 스레드가 동기화 블록으로 들어가면 this(Calculator 객체)를 잠그고, 동기화 블록을 실행한다.
	// 동기화 블록을 모두 실행할 때까지 다른 스레드들은 this(Calculator 객체)의 모든 동기화 메소드 또는 동기화 블록을 실행할 수 없게 된다.
}
