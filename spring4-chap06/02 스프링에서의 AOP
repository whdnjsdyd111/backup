스프링은 자체적으로 프록시 기반의 AOP를 지원하고 있다. 따라서 스프링 AOP는 메소드 호출 Joinpoint만을 지원한다.
필드 값 변경과 같은 Joinpoin를 사용하고 싶다면 AspectJ와 같이 다양한 Joinpoint를 지원하는 AOP 도구를 사용해야 한다.

스프링은 완전한 AOP 기능을 제공하는 것이 목적이 아니라 엔터프라이즈 어플리케이션을 구현하는 데 필요한 기능을 제공하는 것을 목적으로 하고 있다.
필자의 경험에 의하면 스프링이 제공하는 AOP 만으로도 엔터프라이즈 어플리케이션을 구현하는 데 부족함이 없었다.

스프링 AOP의 또 다른 특징은 기반이라는 점이다. AspectJ는 Aspect를 위한 별도의 문법을 제공하고 있는 반면에 스프링은
별도의 문법을 익힐 필요 없이 자바 언어만을 이용하면 된다.

스프링은 세 가지 방식으로 AOP를 구현할 수 있도록 하고 있다.

	- XML 스키마 기반의 POJO 클래스를 이용한 AOP 구현
	- AspectJ에 정의한 @Aspect 어노테이션 기반의 AOP 구현
	- 스프링 API를 이용한 AOP 구현
	
어떤 방식을 사용하더라도 내부적으로는 프록시를 이용하여 AOP가 구현되므로 메소드 호출에 대해서만 AOP를 적용할 수 있다는 것에 유의하자.
(즉, AspectJ에서 정의한 @Aspect 어노테이션을 사용하더라도 메소드 호출과 관련된 Pointcut만 사용 가능하다.)

[개발자가 직접 스프링 AOP API를 사용해서 AOP를 구현하는 경우는 많지 않으며, 일반적으로는 XML 스키마를 이용하거나 @Aspect 어노테이션을 이용해서 AOP를 구현한다.
따라서 XML 스키마 기반 AOP 구현과 @Aspect 어노테이션 기반 AOP 구현 방법을 살펴볼 것이다.
http://goo.gl/P7ulvD	를 참고하자.]


	2.1 프록시를 이용한 AOP 구현
	
스프링은 프록시를 이용하여 AOP를 구현하고 있다. 스프링은 Aspect의 적용 대상(target)이 되는 객체에 대한 프록시를 만들어 제공하며, 대상 객체를 사용하는 코드는
대상 객체에 직접 접근하지 않고 프록시를 통해서 간접적으로 접근하게 된다. 이 과정에서 프록시는 공통 기능을 실행한 뒤 대상 객체의 실제 메소드를 호출하거나 
또는 대상 객체의 실제 메소드를 호출한 후에 공통 기능을 실행하게 된다.


			1: operation()						2: operation()
					→									→
	Client: Client──────────────────proxy: TargetProxy──────target: TargetImpl
	
	
대상 객체는 결국 스프링 빈 객체가 되는데, 스프링은 설정 정보를 이용해서 어떤 빈 객체에 Aspect를 적용할지의 여부를 지정한다.
스프링 컨테이너를 초기화하는 과정에서 설정 정보에 지정한 빈 객체에 대한 프록시 객체를 생성하고, 원본 빈 객체에 대신에 프록시 객체를 사용하도록 한다.

프록시 객체를 생성하는 방식은 대상 객체가 인터페이스를 구현하고 있느냐 없느냐 여부에 따라 달라진다.
대상 객체가 인터페이스를 구현하고 있다면, 스프링은 자바 리플렉션 API가 제공하는 java.lang.reflect.Proxy를 이용하여 프록시 객체를 생성한다.
이때 생성된 프록시 객체는 다음과 같이 대상 객체와 동일한 인터페이스를 구현하게 되며, 클라이언트는 인터페이스를 통해서 필요한 메소드를 호출하게 된다.
하지만, 인터페이스를 기반으로 프록시 객체를 생성하기 때문에 인터페이스에 정의되어 있지 않은 메소드에 대해서는 AOP가 적용되지 않는 점에 유의해야 한다.


		Client	────────────>		<< interface >>
										TargetIF
								
									+ operation()
									
											↑
									┌───────┴───────────┐
								TargetProxy		TargetImpl
								+ operation()	+ operation()
								
								
대상 객체가 인터페이스를 구현하고 있지 않다면, 스프링은 CGLIB를 이용하여 클래스에 대한 프록시 객체를 생성한다.
CGLIB는 대상 클래스를 상속받아 프록시를 구현한다. 따라서, 대상 클래스가 final인 경우 프록시를 생성할 수 없으며, final인 메소드에 대해서는 AOP를 적용할 수 없게 된다.

[많은 프레임워크가 개발 라이브러리가 런타임에 객체를 생성하기 위해 CGLIB를 사용하고 있다.
이들을 함께 사용하다 보면 CGLIB 버전 충돌 문제가 발생할 수 있는데, 이런 충돌 문제가 발생하지 않도록 하기 위해 프레임워크나 라이브러리에 CGLIB의 패키지 구조를 변경해서 포함시키는 경우가
증가하고 있다. 스프링 4 버전도 패키지 구조를 변경한 CGLIB 클래스를 포함하고 있기 때문에 별도 CGLIB 모듈을 필요로 하지 않는다.]


	2.2 구현 가능한 Advice 종류
	
스프링은 프록시를 이용해서 메소드를 호출할 때 Aspect를 적용하기 때문에 구현 가능한 Advice 종류는 다음과 같다.

	종류							설명
	
	Before Advice				대상 객체의 메소드 호출 전에 공통 기능을 실행한다.
	
	After Returning Advice		대상 객체의 메소드가 익셉션 없이 실행된 이후에 공통 기능을 실행한다.
	
	After Throwing Advice		대상 객체의 메소드를 실행하는 도중 익셉션이 발생한 경우에 공통 기능을 실행한다.
	
	After Advice				대상 객체의 메소드를 실행하는 도중 익셉션이 발생했는지의 여부에 상관없이 메소드 실행 후 공통 기능을 실행한다 (try-catch-finally의 finally 블록과 비슷하다.)
	
	Around Advice				대상 객체의 메소드 실행 전, 후 또는 익셉션 발생 시점에 공통 기능을 실행하는데 사용된다.
	
이들 AOP 중에서 범용적으로 사용되는 것은 Around Advice인데, 그 이유는 대상 객체의 메소드를 실행하기 전/후에 원하는 기능을 삽입할 수 있기 때문이다.
이런 이유로 캐시 기능, 성능 모니터링 기능과 같은 Aspect를 구현할 때에는 Around Advice를 주로 이용하게 된다.